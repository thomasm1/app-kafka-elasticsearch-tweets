package xyz.cryptomaven.rest.controllerTests;

import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Order; // For ordering if needed
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.web.reactive.server.WebTestClient;
import org.springframework.transaction.annotation.Transactional;
import xyz.cryptomaven.rest.models.dto.AddressDto; // Import the DTO
import static org.hamcrest.Matchers.*; // For Hamcrest matchers

@TestMethodOrder(MethodOrderer.OrderAnnotation.class) // Use OrderAnnotation if you want explicit order
@Transactional
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
public class AddressesMvcControllerTest {

    @Autowired
    private WebTestClient client;

    private static final String API_BASE_PATH = "/api/addresses"; // Define base path

    @Test
    @Order(1) // Example ordering
    void testGetAllAddresses_ShouldReturnOkAndAddressDtoList() {
        client.get()
                .uri(API_BASE_PATH)
                .accept(MediaType.APPLICATION_JSON) // Good practice to set Accept header
                .exchange()
                .expectStatus().isOk()
                // *** IMPORTANT: Expect DTO, not Entity ***
                .expectBodyList(AddressDto.class)
                // Add more assertions if needed, e.g., check list size if data is preloaded
                .value(list -> System.out.println("GET All Response: " + list)); // Keep for debug if desired
        // .value(list -> assertThat(list.size(), greaterThanOrEqualTo(0))); // Example assertion
    }

    @Test
    @Order(2)
    void testInsertAddress_ShouldReturnCreatedAndAddressDto() {
        AddressDto newAddressDto = AddressDto.builder()
                .email("test" + System.currentTimeMillis() + "@example.com") // Use unique email
                .address("123 Test St " + System.currentTimeMillis()) // Use unique address
                // Add other required fields from AddressDto
                .build();

        client.post()
                .uri(API_BASE_PATH)
                .contentType(MediaType.APPLICATION_JSON)
                .accept(MediaType.APPLICATION_JSON) // Expect JSON response
                .bodyValue(newAddressDto)
                .exchange()
                // *** IMPORTANT: Expect 201 Created for successful POST ***
                .expectStatus().isCreated()
                .expectHeader().contentType(MediaType.APPLICATION_JSON)
                // Assertions on the returned DTO
                .expectBody(AddressDto.class)
                .value(returnedDto -> {
                    System.out.println("POST Response: " + returnedDto); // Debug output
                    // Assert that the returned DTO has an ID (generated by DB)
                    org.assertj.core.api.Assertions.assertThat(returnedDto.getId()).isNotNull();
                    // Assert other fields match the input
                    org.assertj.core.api.Assertions.assertThat(returnedDto.getEmail()).isEqualTo(newAddressDto.getEmail());
                    org.assertj.core.api.Assertions.assertThat(returnedDto.getAddress()).isEqualTo(newAddressDto.getAddress());
                });
    }

    // --- Add More Tests ---

    @Test
    @Order(3)
    void testGetAddressById_WithValidId_ShouldReturnOkAndAddressDto() {
        // --- Arrange ---
        // 1. Create an address first to ensure one exists with a known ID
        AddressDto createdDto = createTestAddress("getbyid@example.com", "456 Get St");
        Long validId = createdDto.getId();

        // --- Act & Assert ---
        client.get()
                .uri(API_BASE_PATH + "/{id}", validId) // Use path variable
                .accept(MediaType.APPLICATION_JSON)
                .exchange()
                .expectStatus().isOk()
                .expectHeader().contentType(MediaType.APPLICATION_JSON)
                .expectBody(AddressDto.class)
                .value(returnedDto -> {
                    org.assertj.core.api.Assertions.assertThat(returnedDto.getId()).isEqualTo(validId);
                    org.assertj.core.api.Assertions.assertThat(returnedDto.getEmail()).isEqualTo(createdDto.getEmail());
                });
    }

    @Test
    @Order(4)
    void testGetAddressById_WithInvalidId_ShouldReturnNotFound() {
        // --- Arrange ---
        Long invalidId = 99999L; // An ID unlikely to exist

        // --- Act & Assert ---
        client.get()
                .uri(API_BASE_PATH + "/{id}", invalidId)
                .accept(MediaType.APPLICATION_JSON)
                .exchange()
                .expectStatus().isNotFound(); // Expect 404
    }


    @Test
    @Order(5)
    void testUpdateAddress_WithValidId_ShouldReturnOkAndAddressDto() {
        // --- Arrange ---
        // 1. Create an address first
        AddressDto createdDto = createTestAddress("update@example.com", "789 Update Ave");
        Long validId = createdDto.getId();

        // 2. Create the update DTO
        AddressDto updateDto = AddressDto.builder()
                .id(validId) // Include the ID for the update target
                .email("updated" + System.currentTimeMillis() + "@example.com")
                .address("987 Updated Blvd")
                // Set other fields as needed
                .build();

        // --- Act & Assert ---
        // Assuming PUT maps to /api/addresses/{id}
        client.put()
                .uri(API_BASE_PATH + "/{id}", validId)
                .contentType(MediaType.APPLICATION_JSON)
                .accept(MediaType.APPLICATION_JSON)
                .bodyValue(updateDto)
                .exchange()
                .expectStatus().isOk() // Or isNoContent() if your PUT returns 204
                .expectHeader().contentType(MediaType.APPLICATION_JSON) // If returning body
                .expectBody(AddressDto.class) // If returning body
                .value(returnedDto -> {
                    org.assertj.core.api.Assertions.assertThat(returnedDto.getId()).isEqualTo(validId);
                    org.assertj.core.api.Assertions.assertThat(returnedDto.getEmail()).isEqualTo(updateDto.getEmail());
                    org.assertj.core.api.Assertions.assertThat(returnedDto.getAddress()).isEqualTo(updateDto.getAddress());
                });

        // Optional: Verify the update by fetching the address again
        client.get()
                .uri(API_BASE_PATH + "/{id}", validId)
                .accept(MediaType.APPLICATION_JSON)
                .exchange()
                .expectStatus().isOk()
                .expectBody(AddressDto.class)
                .value(fetchedDto -> {
                    org.assertj.core.api.Assertions.assertThat(fetchedDto.getEmail()).isEqualTo(updateDto.getEmail());
                });
    }

    @Test
    @Order(6)
    void testUpdateAddress_WithInvalidId_ShouldReturnNotFound() {
        // --- Arrange ---
        Long invalidId = 99999L;
        AddressDto updateDto = AddressDto.builder()
                .id(invalidId)
                .email("no-update@example.com")
                .address("Nowhere St")
                .build();

        // --- Act & Assert ---
        client.put()
                .uri(API_BASE_PATH + "/{id}", invalidId)
                .contentType(MediaType.APPLICATION_JSON)
                .accept(MediaType.APPLICATION_JSON)
                .bodyValue(updateDto)
                .exchange()
                // Assuming your controller/service correctly handles non-existent updates
                .expectStatus().isNotFound(); // Or perhaps isBadRequest() depending on impl
    }


    @Test
    @Order(7)
    void testDeleteAddress_WithValidId_ShouldReturnOk() {
        // --- Arrange ---
        // 1. Create an address first
        AddressDto createdDto = createTestAddress("delete@example.com", "1 Delete Pl");
        Long validId = createdDto.getId();

        // --- Act & Assert ---
        client.delete()
                .uri(API_BASE_PATH + "/{id}", validId)
                .exchange()
                .expectStatus().isOk() // Or isNoContent() if your DELETE returns 204
                .expectBody(Boolean.class).isEqualTo(true); // If your controller returns boolean

        // --- Verify ---
        // Try to get the deleted address, expect 404
        client.get()
                .uri(API_BASE_PATH + "/{id}", validId)
                .accept(MediaType.APPLICATION_JSON)
                .exchange()
                .expectStatus().isNotFound();
    }

    @Test
    @Order(8)
    void testDeleteAddress_WithInvalidId_ShouldReturnOkOrNotFound() {
        // --- Arrange ---
        Long invalidId = 99999L;

        // --- Act & Assert ---
        client.delete()
                .uri(API_BASE_PATH + "/{id}", invalidId)
                .exchange()
                // Depending on your controller's implementation for deleting non-existent items:
                .expectStatus().isOk() // If it returns OK + false body
                .expectBody(Boolean.class).isEqualTo(false);
        // OR
        // .expectStatus().isNotFound(); // If it returns 404
    }


    // Helper method to create an address for use in other tests
    private AddressDto createTestAddress(String email, String addressStr) {
        AddressDto newAddressDto = AddressDto.builder()
                .email(email)
                .address(addressStr)
                .build();

        return client.post()
                .uri(API_BASE_PATH)
                .contentType(MediaType.APPLICATION_JSON)
                .accept(MediaType.APPLICATION_JSON)
                .bodyValue(newAddressDto)
                .exchange()
                .expectStatus().isCreated()
                .expectBody(AddressDto.class)
                .returnResult().getResponseBody();
    }
}